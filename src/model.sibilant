(include "kit/header")
(import-namespace kit)
(namespace language-model)

(require! (lit Probability-tree) "./probability-tree")


(def-interface Model ((*root ((create Probability-tree)))
                      (*nodes []))

  (init (assign *root.*model this))


  (gett total this.*root.count)

  (def each (f) (.each this.*root f) this)

  (models (new Map))
  (def-generic generate-random-phrase (n (m this))

    (print "generating")
    (var t (.random m))

    (var gram (rest t.seq))
    (var out [])
    (do-times n

      (print "t" t.seq t.likelyhood)
      (print "gram" gram)
      (assign t (.random (.given m gram)))
      (assign gram (rest t.seq))
      (.push out (last t.seq)))
    (.join out " "))

  (def *next-gram (m)
    (=> (gram t)
        (.add m gram)
        [(dots (rest gram)) t]))
  (def-generic train (n tokens (m this) *next-gram )
    (macro array-of (n ...body)
           `(scoped
             (var r [])
             (do-times @n (.push r (scoped ...@body)))
             r))
    (var gram (array-of n null))
    (.push tokens (dots gram))
    (.reduce tokens  (*next-gram m)))

  (def-generic given (seq models)
    (if (> seq.length 0)
        (let ((*root (.find this.*root seq))
              (*nodes []))

          (if *root
              (do (each *root (node)
                        (if (not (= node.value null))
                            (.push *nodes node)))

                  (remember models *root
                            (pipe *nodes (.sort  (=> (a b) (- a.count b.count))))
                            ((create Model) ((create *root) null null *root.children) *nodes)))
              (throw (new Error "mis counting has occured"))
              ))
        this)

    )

  (def random ()

    (.sort this)
    (var t this.total)

    (var r (Math.floor (* (Math.random) t))
         c 0
         i 0)


    (var node (get this.*nodes i))

    (incr-by c node.count)

    (until (>= c r)

           (++ i)
           (assign node (get this.*nodes i))
           (incr-by c node.count)) node)


  (def likelyhood (seq)
    (var node (.find this.*root seq))
    (/ node.count
       this.total ))
  (def save (fs path ))

  (def sort () (.sort this.*nodes (=> (a b) (- a.count b.count))))

  (def degrade (seq)
    ;; Broken, not sure why
    (var node (.find this.*root seq))
    (if (and (not (= null node))
             (defined? node)
             (> node.count 1))
        (until (= node null)
               (-- node.count)
               (assign node node.parent))))

  (def add (seq )
    ;; (cond
    ;;   (#-> (get 'value))
    ;;   (#-> (get 'count))
    ;;   (#-> (set 'value (lit seq (count 1)))
    ;;          )
    ;;   node)
    (var  node (.insert this.*root seq ))
    (if node.value
        (assign node.value.count (+ node.count 1))
        (do (assign node.value (lit seq (count 1)))
            (.push  this.*nodes node)))
    node))

(export Model)
